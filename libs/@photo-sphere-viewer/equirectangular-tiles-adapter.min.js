/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@photo-sphere-viewer/equirectangular-tiles-adapter@5.10.1/index.module.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * Photo Sphere Viewer / Equirectangular Tiles Adapter 5.10.1
 * @copyright 2015-2024 Damien "Mistic" Sorel
 * @licence MIT (https://opensource.org/licenses/MIT)
 */
import{AbstractAdapter,CONSTANTS,EquirectangularAdapter,PSVError as PSVError3,events,utils as utils2}from"@photo-sphere-viewer/core";import{MathUtils as MathUtils2,Mesh,MeshBasicMaterial as MeshBasicMaterial2,SphereGeometry,Vector3}from"three";var Task=class{constructor(e,t,i){this.id=e,this.priority=t,this.fn=i,this.status=1}start(){return this.status=2,this.fn(this).then((()=>{this.status=4}),(()=>{this.status=5}))}cancel(){this.status=3}isCancelled(){return 3===this.status}},Queue=class{constructor(e=4){this.concurency=e,this.runningTasks={},this.tasks={}}enqueue(e){this.tasks[e.id]=e}clear(){Object.values(this.tasks).forEach((e=>e.cancel())),this.tasks={},this.runningTasks={}}setPriority(e,t){const i=this.tasks[e];i&&(i.priority=t,0===i.status&&(i.status=1))}disableAllTasks(){Object.values(this.tasks).forEach((e=>{e.status=0}))}start(){if(Object.keys(this.runningTasks).length>=this.concurency)return;const e=Object.values(this.tasks).filter((e=>1===e.status)).sort(((e,t)=>t.priority-e.priority)).pop();e&&(this.runningTasks[e.id]=!0,e.start().then((()=>{e.isCancelled()||(delete this.tasks[e.id],delete this.runningTasks[e.id],this.start())})),this.start())}};import{PSVError,utils}from"@photo-sphere-viewer/core";import{LineSegments,MeshBasicMaterial,WireframeGeometry}from"three";function checkTilesLevels(e){let t=0;e.forEach(((i,s)=>{if(!i.zoomRange||2!==i.zoomRange.length)throw new PSVError(`Tiles level ${s} is missing "zoomRange" property`);if(i.zoomRange[0]>=i.zoomRange[1]||i.zoomRange[0]!==t||0===s&&0!==i.zoomRange[0]||s===e.length-1&&100!==i.zoomRange[1])throw new PSVError('Tiles levels\' "zoomRange" are not orderer or are not covering the whole 0-100 range');t=i.zoomRange[1]}))}function getTileIndexByZoomLevel(e,t){return e.findIndex((e=>t>=e.zoomRange[0]&&t<=e.zoomRange[1]))}function buildErrorMaterial(){const e=document.createElement("canvas");e.width=512,e.height=512;const t=e.getContext("2d");return t.fillStyle="#333",t.fillRect(0,0,e.width,e.height),t.font=e.width/5+"px serif",t.fillStyle="#a22",t.textAlign="center",t.textBaseline="middle",t.fillText("âš ",e.width/2,e.height/2),new MeshBasicMaterial({map:utils.createTexture(e)})}function createWireFrame(e){const t=new WireframeGeometry(e),i=new LineSegments(t);return i.material.depthTest=!1,i.material.opacity=.25,i.material.transparent=!0,i}var DEBUG_COLORS=["dodgerblue","limegreen","indianred"];function buildDebugTexture(e,t,i){const s=document.createElement("canvas");s.width=e.width,s.height=e.height;const r=s.getContext("2d");r.fillStyle=DEBUG_COLORS[t%DEBUG_COLORS.length],r.fillRect(0,0,s.width,s.height),r.globalCompositeOperation="multiply",r.drawImage(e,0,0);const o=e.width/7;return r.globalCompositeOperation="source-over",r.fillStyle="white",r.font=`${o}px monospace`,r.textAlign="center",i.split("\n").forEach(((t,i)=>{r.fillText(t,e.width/2,e.height/2+o*(.3+i))})),s}import{PSVError as PSVError2}from"@photo-sphere-viewer/core";import{MathUtils}from"three";function isMultiTiles(e){return!!e.levels}function computeTileConfig(e,t,i){return{...e,level:t,colSize:e.width/e.cols,rowSize:e.width/2/e.rows,facesByCol:i.SPHERE_SEGMENTS/e.cols,facesByRow:i.SPHERE_HORIZONTAL_SEGMENTS/e.rows}}function getTileConfig(e,t,i){let s,r;return isMultiTiles(e)?(r=getTileIndexByZoomLevel(e.levels,t),s=e.levels[r]):(r=0,s={...e,zoomRange:[0,100]}),computeTileConfig(s,r,i)}function getTileConfigByIndex(e,t,i){return isMultiTiles(e)&&e.levels[t]?computeTileConfig(e.levels[t],t,i):null}function checkPanoramaConfig(e,t){if("object"!=typeof e||!e.tileUrl)throw new PSVError2("Invalid panorama configuration, are you using the right adapter?");isMultiTiles(e)?(e.levels.forEach((e=>checkTile(e,t))),checkTilesLevels(e.levels)):checkTile(e,t)}function checkTile(e,t){if(!e.width||!e.cols||!e.rows)throw new PSVError2("Invalid panorama configuration, are you using the right adapter?");if(e.cols>t.SPHERE_SEGMENTS)throw new PSVError2(`Panorama cols must not be greater than ${t.SPHERE_SEGMENTS}.`);if(e.rows>t.SPHERE_HORIZONTAL_SEGMENTS)throw new PSVError2(`Panorama rows must not be greater than ${t.SPHERE_HORIZONTAL_SEGMENTS}.`);if(!MathUtils.isPowerOfTwo(e.cols)||!MathUtils.isPowerOfTwo(e.rows))throw new PSVError2("Panorama cols and rows must be powers of 2.")}var NB_VERTICES_BY_FACE=6,NB_VERTICES_BY_SMALL_FACE=3,ATTR_UV="uv",ATTR_ORIGINAL_UV="originaluv",ATTR_POSITION="position",ERROR_LEVEL=-1;function tileId(e){return`${e.col}x${e.row}/${e.config.level}`}var getConfig=utils2.getConfigParser({backgroundColor:"#000",resolution:64,showErrorTile:!0,baseBlur:!0,antialias:!0,debug:!1,useXmpData:!1},{resolution:e=>{if(!e||!MathUtils2.isPowerOfTwo(e))throw new PSVError3("EquirectangularTilesAdapter resolution must be power of two");return e}}),vertexPosition=new Vector3,EquirectangularTilesAdapter=class extends AbstractAdapter{constructor(e,t){super(e),this.state={tileConfig:null,tiles:{},faces:{},geom:null,materials:[],errorMaterial:null,inTransition:!1},this.queue=new Queue,this.config=getConfig(t),this.SPHERE_SEGMENTS=this.config.resolution,this.SPHERE_HORIZONTAL_SEGMENTS=this.SPHERE_SEGMENTS/2,this.NB_VERTICES=2*this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE+(this.SPHERE_HORIZONTAL_SEGMENTS-2)*this.SPHERE_SEGMENTS*NB_VERTICES_BY_FACE,this.NB_GROUPS=this.SPHERE_SEGMENTS*this.SPHERE_HORIZONTAL_SEGMENTS,this.viewer.config.requestHeaders&&utils2.logWarn('EquirectangularTilesAdapter fallbacks to file loader because "requestHeaders" where provided. Consider removing "requestHeaders" if you experience performances issues.')}init(){super.init(),this.viewer.addEventListener(events.PositionUpdatedEvent.type,this),this.viewer.addEventListener(events.ZoomUpdatedEvent.type,this)}destroy(){this.viewer.addEventListener(events.PositionUpdatedEvent.type,this),this.viewer.addEventListener(events.ZoomUpdatedEvent.type,this),this.__cleanup(),this.state.errorMaterial?.map?.dispose(),this.state.errorMaterial?.dispose(),this.adapter?.destroy(),delete this.adapter,delete this.state.geom,delete this.state.errorMaterial,super.destroy()}handleEvent(e){(e instanceof events.PositionUpdatedEvent||e instanceof events.ZoomUpdatedEvent)&&this.__refresh()}supportsTransition(e){return!!e.baseUrl}supportsPreload(e){return!!e.baseUrl}textureCoordsToSphericalCoords(e,t){return this.getAdapter().textureCoordsToSphericalCoords(e,t)}sphericalCoordsToTextureCoords(e,t){return this.getAdapter().sphericalCoordsToTextureCoords(e,t)}loadTexture(e,t=!0){try{checkPanoramaConfig(e,this)}catch(e){return Promise.reject(e)}const i=getTileConfig(e,0,this),s={isEquirectangular:!0,fullWidth:i.width,fullHeight:i.width/2,croppedWidth:i.width,croppedHeight:i.width/2,croppedX:0,croppedY:0,poseHeading:0,posePitch:0,poseRoll:0};return e.baseUrl?this.getAdapter().loadTexture(e.baseUrl,t,e.basePanoData,!1).then((t=>({panorama:e,panoData:s,cacheKey:t.cacheKey,texture:t.texture}))):Promise.resolve({panorama:e,panoData:s,cacheKey:e.tileUrl(0,0,0),texture:null})}createMesh(){const e=new SphereGeometry(CONSTANTS.SPHERE_RADIUS,this.SPHERE_SEGMENTS,this.SPHERE_HORIZONTAL_SEGMENTS,-Math.PI/2).scale(-1,1,1).toNonIndexed();e.clearGroups();let t=0,i=0;for(;t<this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE;t+=NB_VERTICES_BY_SMALL_FACE)e.addGroup(t,NB_VERTICES_BY_SMALL_FACE,i++);for(;t<this.NB_VERTICES-this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE;t+=NB_VERTICES_BY_FACE)e.addGroup(t,NB_VERTICES_BY_FACE,i++);for(;t<this.NB_VERTICES;t+=NB_VERTICES_BY_SMALL_FACE)e.addGroup(t,NB_VERTICES_BY_SMALL_FACE,i++);return e.setAttribute(ATTR_ORIGINAL_UV,e.getAttribute(ATTR_UV).clone()),new Mesh(e,[])}setTexture(e,t,i){const{texture:s}=t;if(i)return this.state.inTransition=!0,void this.__setTexture(e,s,!0);if(this.__cleanup(),this.__setTexture(e,s,!1),this.state.materials=e.material,this.state.geom=e.geometry,this.state.geom.setAttribute(ATTR_UV,this.state.geom.getAttribute(ATTR_ORIGINAL_UV).clone()),this.config.debug){const e=createWireFrame(this.state.geom);this.viewer.renderer.addObject(e),this.viewer.renderer.setSphereCorrection(this.viewer.config.sphereCorrection,e)}setTimeout((()=>this.__refresh()))}__setTexture(e,t,i){let s;s=new MeshBasicMaterial2(t?{map:t}:{color:this.config.backgroundColor}),i&&(s.depthTest=!1,s.depthWrite=!1);for(let t=0;t<this.NB_GROUPS;t++)e.material.push(s)}setTextureOpacity(e,t){e.material[0].opacity=t,e.material[0].transparent=t<1}disposeTexture(e){e.texture?.dispose()}__refresh(){if(!this.state.geom||this.state.inTransition)return;const e=this.viewer.config.panorama,t=getTileConfig(e,this.viewer.getZoomLevel(),this),i=this.state.geom.getAttribute(ATTR_POSITION),s={};for(let r=0;r<this.NB_VERTICES;r+=1)if(vertexPosition.fromBufferAttribute(i,r),vertexPosition.applyEuler(this.viewer.renderer.sphereCorrection),this.viewer.renderer.isObjectVisible(vertexPosition)){let i;i=r<this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE?Math.floor(r/3):r<this.NB_VERTICES-this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE?Math.floor((r/3-this.SPHERE_SEGMENTS)/2)+this.SPHERE_SEGMENTS:Math.floor((r-this.NB_VERTICES-this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE)/3)+this.SPHERE_HORIZONTAL_SEGMENTS*(this.SPHERE_SEGMENTS-1);const o=Math.floor(i/this.SPHERE_SEGMENTS),a=i-o*this.SPHERE_SEGMENTS;let n=t;for(;n;){const t=Math.floor(o/n.facesByRow),i=Math.floor(a/n.facesByCol);let r=vertexPosition.angleTo(this.viewer.state.direction);0!==t&&t!==n.rows-1||(r*=2);const l={row:t,col:i,angle:r,config:n,url:null},h=tileId(l);if(s[h]){s[h].angle=Math.min(s[h].angle,r);break}if(l.url=e.tileUrl(i,t,n.level),l.url){s[h]=l;break}n=getTileConfigByIndex(e,n.level-1,this)}}this.state.tileConfig=t,this.__loadTiles(Object.values(s))}__loadTiles(e){this.queue.disableAllTasks(),e.forEach((e=>{const t=tileId(e);this.state.tiles[t]?this.queue.setPriority(t,e.angle):(this.state.tiles[t]=!0,this.queue.enqueue(new Task(t,e.angle,(t=>this.__loadTile(e,t)))))})),this.queue.start()}__loadTile(e,t){return this.viewer.textureLoader.loadImage(e.url,null,this.viewer.state.textureData.cacheKey).then((i=>{if(!t.isCancelled()){this.config.debug&&(i=buildDebugTexture(i,e.config.level,tileId(e)));const t=this.config.antialias&&e.config.level>0,s=new MeshBasicMaterial2({map:utils2.createTexture(i,t)});this.__swapMaterial(e,s,!1),this.viewer.needsUpdate()}})).catch((i=>{utils2.isAbortError(i)||t.isCancelled()||!this.config.showErrorTile||(this.state.errorMaterial||(this.state.errorMaterial=buildErrorMaterial()),this.__swapMaterial(e,this.state.errorMaterial,!0),this.viewer.needsUpdate())}))}__swapMaterial(e,t,i){const s=this.state.geom.getAttribute(ATTR_UV);for(let r=0;r<e.config.facesByCol;r++)for(let o=0;o<e.config.facesByRow;o++){const a=e.col*e.config.facesByCol+r,n=e.row*e.config.facesByRow+o,l=0===n,h=n===this.SPHERE_HORIZONTAL_SEGMENTS-1;let E;if(E=l?a*NB_VERTICES_BY_SMALL_FACE:h?this.NB_VERTICES-this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE+a*NB_VERTICES_BY_SMALL_FACE:this.SPHERE_SEGMENTS*NB_VERTICES_BY_SMALL_FACE+(n-1)*this.SPHERE_SEGMENTS*NB_VERTICES_BY_FACE+a*NB_VERTICES_BY_FACE,i&&this.state.faces[E]>ERROR_LEVEL)continue;if(this.state.faces[E]>e.config.level)continue;this.state.faces[E]=i?ERROR_LEVEL:e.config.level;const c=this.state.geom.groups.find((e=>e.start===E)).materialIndex;this.state.materials[c]=t;const u=1-o/e.config.facesByRow,d=1-(o+1)/e.config.facesByRow,_=r/e.config.facesByCol,S=(r+1)/e.config.facesByCol;l?(s.setXY(E,(_+S)/2,u),s.setXY(E+1,_,d),s.setXY(E+2,S,d)):h?(s.setXY(E,S,u),s.setXY(E+1,_,u),s.setXY(E+2,(_+S)/2,d)):(s.setXY(E,S,u),s.setXY(E+1,_,u),s.setXY(E+2,S,d),s.setXY(E+3,_,u),s.setXY(E+4,_,d),s.setXY(E+5,S,d))}s.needsUpdate=!0}__cleanup(){this.queue.clear(),this.state.tiles={},this.state.faces={},this.state.inTransition=!1,this.state.materials.forEach((e=>{e?.map?.dispose(),e?.dispose()})),this.state.materials.length=0}getAdapter(){return this.adapter||(this.adapter=new EquirectangularAdapter(this.viewer,{backgroundColor:this.config.backgroundColor,interpolateBackground:!1,blur:this.config.baseBlur})),this.adapter}};EquirectangularTilesAdapter.id="equirectangular-tiles",EquirectangularTilesAdapter.VERSION="5.10.1",EquirectangularTilesAdapter.supportsDownload=!1;export{EquirectangularTilesAdapter};
//# sourceMappingURL=/sm/2e9084dfe11482ed77fce251354cd4a8296e9be0b21edbb5c3e21478e561cf8e.map